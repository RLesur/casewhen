% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/create_case_when.R
\name{create_sql_case_when}
\alias{create_sql_case_when}
\title{Create a reusable SQL case_when function}
\usage{
create_sql_case_when(..., vars = "x", con = NULL,
  fn = dplyr::sql_translate_env(con = con)$scalar$case_when)
}
\arguments{
\item{...}{A sequence of two-sided formulas. The left hand side (LHS)
determines which values match this case. The right hand side (RHS)
provides the replacement value.

The LHS must evaluate to a logical vector. Each logical vector can
either have length 1 or a common length. All RHSs must evaluate to
the same type of vector.

These dots are evaluated with \link[rlang:dots_list]{explicit splicing}.}

\item{vars}{A character vector that determined the names of the arguments
of the returned function.}

\item{con}{A database connection.}

\item{fn}{A function to be used by the returned function.}
}
\description{
This function is a helper devoted to developers that want to add a custom
\code{case_when} function to a \link[dbplyr:sql_variant]{SQL translator}. In this case,
you should use the \code{fn} argument instead of the \code{con} argument.
}
\examples{
con <- structure(
  list(),
  class = c("TestCon", "Oracle", "DBITestConnection", "DBIConnection")
)

fn <- dplyr::sql_translate_env(con)$scalar$case_when

cw_fb <- create_sql_case_when(
  number \%\% 35 == 0 ~ "fizz buzz",
  number \%\% 5 == 0 ~ "fizz",
  number \%\% 7 == 0 ~ "buzz",
  TRUE ~ as.character(number),
  vars = "number",
  fn = fn
)

testcon_var <- dbplyr::sql_variant(
  dbplyr::sql_translator(
    cw_fb = cw_fb,
    .parent = dplyr::sql_translate_env(con)$scalar
  ),
  dplyr::sql_translate_env(con)$aggregate,
  dplyr::sql_translate_env(con)$window
)

sql_translate_env.TestCon <- function(x) testcon_var

dbplyr::translate_sql(cw_fb(x), con = con)
}
\keyword{internal}
